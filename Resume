1.Introdução
  -> Um Breve Resumo
    Cap2 - Discute algumas metodologias de aplicação e armadilhas do Java
    Cap3 - Overview de ferramentas dispniveis para monitoramento de aplicações
    Cap4 - JIT compilation
    Cap5 e Cap6 - Garbage Collection
    Cap7 - Uso de memoria com Java Heap
    Cap8 - Uso de memoria com memoria nativa
    Cap9 - Performance de Thread
    Cap10 - JEE APIs
    Cap11 - JPA e JDBC
    Cap12 - Dicas gerais da API do Java SE
  
  -> Pataformas e Convenções
    -> Utilizado o JVM padrão HotSpot da Oracle
    -> Java 7 ou superior
    -> Implementacao do Garbage G1 - Java 7
    
  -> JVM Tunning Flags
    -> Flag boleano ligado = -XX:+FlagsName
    -> Flag boleano desligado = -XX:-FlagsName
      _Client Class and Server Class
        -> Máquinas de 32-bit são considerado pela JVM client class
        -> Máquinas de 64-bit são considerado pela JVM server class
    
  -> A história de performance completa
    -> Escreva algoritmos melhores
      -> Não existe uma flag com a opção mágica -XX:+RunReallyFast
      -> Realmente a JVM otimiza seu for iterando um array para buscar um nome, mas seria melhor utilizar um HashMap
    -> Escreva menos Código
      -> Quanto mais código tiver para ser compilado mais tempo levará para rodar
      -> Quanto mais objeto tiver que ser alocado e discartado, mais trabalho o GC ira ter.
      -> Quanto mais objeto tiver que ser alocado e retidos, mais tempo o ciclo do GC vai demorar.
      -> Quanto mais classes tiver que ser carregado do disco para a JVM, mais longo irá ser a inicialização da aplicação.
        _Nós iremos em última analise sempre perder a guerra
          -> Na verdade ao decorrer do tempo a perfonce vai caindo devido a inclusão de novas features
          -> E para isso novos padrões são adotados
          -> Exemplo é o Firefox 23... ele abrirá mais lentamente um HTML padrão do que um MAC Quadra 95
          
  -> Oh então vamos em frente, Otimização Prematura
    <<<<<<-- Donald Knuth -->>>>>>
    
  

